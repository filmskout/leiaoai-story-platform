import{e as u}from"./utils-BXRRhCbk.js";import{concatHex as V}from"./concat-hex-DPpLtwyv.js";import{readContract as C}from"./read-contract-Cp90h2iM.js";import{aR as h,aS as P,aB as c,aT as w,aU as _,aV as H,aW as U,aX as $,f as A,av as T,ae as S}from"./Auth-Da7edH4x.js";import{p as E}from"./index-Cy5vKj6j.js";import"./to-serializable-transaction-CpnW1tN4.js";import"./index-BZnjROPM.js";import"./mail-Dd9q-fNT.js";import"./eye-off-CTxfvyry.js";import"./eye-B3RkKAfO.js";import"./circle-alert-BkMsUCVY.js";import"./loader-circle-Cs0sZM6W.js";import"./bundler-Ps6QYQUc.js";import"./addresses-Cbjra2SQ.js";import"./send-eip712-transaction-5lbJJuVE.js";import"./eth_sendRawTransaction-DPdnXbFR.js";import"./sha2-D3jwzLbD.js";import"./random-B1VyicZo.js";import"./send-transaction-DOA-1YsO.js";const F="0x1626ba7e",O=[{name:"hash",type:"bytes32"},{name:"signature",type:"bytes"}],B=[{type:"bytes4"}];async function L(t){return C({contract:t.contract,method:[F,O,B],params:[t.hash,t.signature]})}const N="0x6492649264926492649264926492649264926492649264926492649264926492";function v({address:t,data:n,signature:e}){return V([u([{type:"address"},{type:"bytes"},{type:"bytes"}],[t,n,e]),N])}const R="0x1626ba7e";async function b({hash:t,signature:n,contract:e}){try{return await L({contract:e,hash:t,signature:n})===R}catch(r){return console.error("Error verifying EIP-1271 signature",r),!1}}const k=`Ethereum Signed Message:
`;function G(t,n){const e=typeof t=="string"?h(t):t.raw instanceof Uint8Array?t.raw:P(t.raw),r=h(`${k}${e.length}`);return c(w(r,e),n)}function j(t){const{domain:n={},message:e,primaryType:r}=t,s={EIP712Domain:_(n),...t.types};H({domain:n,message:e,primaryType:r,types:s});const a=["0x1901"];if(n&&a.push(U({domain:n,types:s})),r!=="EIP712Domain"){const i=(()=>{const o=x({data:e,primaryType:r,types:s});return c(o)})();a.push(i)}return c(w(...a.map(i=>$(i))))}function x({data:t,primaryType:n,types:e}){const r=[{type:"bytes32"}],s=[z({primaryType:n,types:e})];if(!e[n])throw new Error("Invalid types");for(const a of e[n]){const[i,o]=M({name:a.name,type:a.type,types:e,value:t[a.name]});r.push(i),s.push(o)}return u(r,s)}function z({primaryType:t,types:n}){const e=A(W({primaryType:t,types:n}));return c(e)}function W({primaryType:t,types:n}){let e="";const r=D({primaryType:t,types:n});r.delete(t);const s=[t,...Array.from(r).sort()];for(const a of s){if(!n[a])throw new Error("Invalid types");e+=`${a}(${n[a].map(({name:i,type:o})=>`${o} ${i}`).join(",")})`}return e}function D({primaryType:t,types:n},e=new Set){const r=t.match(/^\w*/u),s=r==null?void 0:r[0];if(e.has(s)||n[s]===void 0)return e;e.add(s);for(const a of n[s])D({primaryType:a.type,types:n},e);return e}function M({types:t,name:n,type:e,value:r}){if(t[e]!==void 0)return[{type:"bytes32"},c(x({data:r,primaryType:e,types:t}))];if(e==="bytes")return r=`0x${(r.length%2?"0":"")+r.slice(2)}`,[{type:"bytes32"},c(r)];if(e==="string")return[{type:"bytes32"},c(A(r))];if(e.lastIndexOf("]")===e.length-1){const s=e.slice(0,e.lastIndexOf("[")),a=r.map(i=>M({name:n,type:s,types:t,value:i}));return[{type:"bytes32"},c(u(a.map(([i])=>i),a.map(([,i])=>i)))]}return[{type:e},r]}async function fe({accountContract:t,factoryContract:n,options:e,message:r}){var f,p;const s=G(r);let a;const i=u([{type:"bytes32"}],[s]);if(a=await e.personalAccount.signTypedData({domain:{chainId:e.chain.id,name:"Account",verifyingContract:t.address,version:"1"},message:{message:i},primaryType:"AccountMessage",types:{AccountMessage:[{name:"message",type:"bytes"}]}}),await T(t)){if(await b({contract:t,hash:s,signature:a}))return a;throw new Error("Failed to verify signature")}else{const d=E({accountSalt:(f=e.overrides)==null?void 0:f.accountSalt,adminAddress:e.personalAccount.address,createAccountOverride:(p=e.overrides)==null?void 0:p.createAccount,factoryContract:n});if(!d)throw new Error("Create account override not provided");const y=await S(d);return v({address:n.address,data:y,signature:a})}}async function me({accountContract:t,factoryContract:n,options:e,typedData:r}){var p,d,y,m,l;if(((d=(p=r.domain)==null?void 0:p.verifyingContract)==null?void 0:d.toLowerCase())===((y=t.address)==null?void 0:y.toLowerCase()))return e.personalAccount.signTypedData(r);const a=j(r);let i;const o=u([{type:"bytes32"}],[a]);if(i=await e.personalAccount.signTypedData({domain:{chainId:e.chain.id,name:"Account",verifyingContract:t.address,version:"1"},message:{message:o},primaryType:"AccountMessage",types:{AccountMessage:[{name:"message",type:"bytes"}]}}),await T(t)){if(await b({contract:t,hash:a,signature:i}))return i;throw new Error("Failed to verify signature")}else{const g=E({accountSalt:(m=e.overrides)==null?void 0:m.accountSalt,adminAddress:e.personalAccount.address,createAccountOverride:(l=e.overrides)==null?void 0:l.createAccount,factoryContract:n});if(!g)throw new Error("Create account override not provided");const I=await S(g);return v({address:n.address,data:I,signature:i})}}export{fe as smartAccountSignMessage,me as smartAccountSignTypedData};
