import{p as H,e as z,i as V,a as A}from"./utils-Cnph8u2h.js";import{B as q,J as W,R as b,af as K,ag as x,a6 as N,H as M,I as $,T as P,ah as Z,ai as L,aj as j,a3 as J,ak as E,K as Q,a9 as Y,f as X,i as ee,D as te,g as ne,s as I,al as R,a8 as h,am as re}from"./Auth-S95xDGpl.js";import{a as S,b as se,e as ae,d as F,P as ie,c as oe}from"./to-serializable-transaction-CC4aNdBJ.js";class ce extends q{constructor(e){super(`Filter type "${e}" is not supported.`,{name:"FilterTypeNotSupportedError"})}}const v=S;function ue(t){const{abi:e,args:n=[],name:s}=t,u=W(s,{strict:!1}),i=e.filter(a=>u?a.type==="function"?se(a)===s:a.type==="event"?v(a)===s:!1:"name"in a&&a.name===s);if(i.length===0)return;if(i.length===1)return i[0];let r;for(const a of i){if(!("inputs"in a))continue;if(!n||n.length===0){if(!a.inputs||a.inputs.length===0)return a;continue}if(!a.inputs||a.inputs.length===0||a.inputs.length!==n.length)continue;if(n.every((o,f)=>{const p="inputs"in a&&a.inputs[f];return p?G(o,p):!1})){if(r&&"inputs"in r&&r.inputs){const o=C(a.inputs,r.inputs,n);if(o)throw new K({abiItem:a,type:o[0]},{abiItem:r,type:o[1]})}r=a}}return r||i[0]}function G(t,e){const n=typeof t,s=e.type;switch(s){case"address":return b(t,{strict:!1});case"bool":return n==="boolean";case"function":return n==="string";case"string":return n==="string";default:return s==="tuple"&&"components"in e?Object.values(e.components).every((u,i)=>G(Object.values(t)[i],u)):/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(s)?n==="number"||n==="bigint":/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(s)?n==="string"||t instanceof Uint8Array:/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(s)?Array.isArray(t)&&t.every(u=>G(u,{...e,type:s.replace(/(\[[0-9]{0,}\])$/,"")})):!1}}function C(t,e,n){for(const s in t){const u=t[s],i=e[s];if(u.type==="tuple"&&i.type==="tuple"&&"components"in u&&"components"in i)return C(u.components,i.components,n[s]);const r=[u.type,i.type];if(r.includes("address")&&r.includes("bytes20")?!0:r.includes("address")&&r.includes("string")?b(n[s],{strict:!1}):r.includes("address")&&r.includes("bytes")?b(n[s],{strict:!1}):!1)return r}}const T="/docs/contract/encodeEventTopics";function de(t){var c;const{abi:e,eventName:n,args:s}=t;let u=e[0];if(n){const o=ue({abi:e,name:n});if(!o)throw new x(n,{docsPath:T});u=o}if(u.type!=="event")throw new x(void 0,{docsPath:T});const i=N(u),r=v(i);let a=[];if(s&&"inputs"in u){const o=(c=u.inputs)==null?void 0:c.filter(p=>"indexed"in p&&p.indexed),f=Array.isArray(s)?s:Object.values(s).length>0?(o==null?void 0:o.map(p=>s[p.name]))??[]:[];f.length>0&&(a=(o==null?void 0:o.map((p,m)=>Array.isArray(f[m])?f[m].map((w,y)=>B({param:p,value:f[m][y]})):typeof f[m]<"u"&&f[m]!==null?B({param:p,value:f[m]}):null))??[])}return[r,...a]}function B({param:t,value:e}){if(t.type==="string"||t.type==="bytes")return M($(e));if(t.type==="tuple"||t.type.match(/^(.*)\[(\d+)?\]$/))throw new ce(t.type);return ae([t],[e])}function fe(t,e){if(!b(t,{strict:!1}))throw new P({address:t});if(!b(e,{strict:!1}))throw new P({address:e});return t.toLowerCase()===e.toLowerCase()}const _="/docs/contract/decodeEventLog";function pe(t){const{abi:e,data:n,strict:s,topics:u}=t,i=s??!0,[r,...a]=u;if(!r)throw new Z({docsPath:_});const c=e.find(d=>d.type==="event"&&r===v(N(d)));if(!(c&&"name"in c)||c.type!=="event")throw new L(r,{docsPath:_});const{name:o,inputs:f}=c,p=f==null?void 0:f.some(d=>!("name"in d&&d.name)),m=p?[]:{},w=f.map((d,l)=>[d,l]).filter(([d])=>"indexed"in d&&d.indexed);for(let d=0;d<w.length;d++){const[l,O]=w[d],U=a[d];if(!U)throw new j({abiItem:c,param:l});m[p?O:l.name||O]=le({param:l,value:U})}const y=f.filter(d=>!("indexed"in d&&d.indexed));if(y.length>0){if(n&&n!=="0x")try{const d=F(y,n);if(d)if(p)for(let l=0;l<f.length;l++)m[l]=m[l]??d.shift();else for(let l=0;l<y.length;l++)m[y[l].name]=d[l]}catch(d){if(i)throw d instanceof J||d instanceof ie?new E({abiItem:c,data:n,params:y,size:Q(n)}):d}else if(i)throw new E({abiItem:c,data:"0x",params:y,size:0})}return{eventName:o,args:Object.values(m).length>0?m:void 0}}function le({param:t,value:e}){return t.type==="string"||t.type==="bytes"||t.type==="tuple"||t.type.match(/^(.*)\[(\d+)?\]$/)?e:(F([t],e)||[])[0]}function me(t){const{abi:e,args:n,logs:s,strict:u=!0}=t,i=(()=>{if(t.eventName)return Array.isArray(t.eventName)?t.eventName:[t.eventName]})();return s.map(r=>{var a;try{const c=e.find(f=>f.type==="event"&&r.topics[0]===v(f));if(!c)return null;const o=pe({...r,abi:[c],strict:u});return i&&!i.includes(o.eventName)||!ye({args:o.args,inputs:c.inputs,matchArgs:n})?null:{...o,...r}}catch(c){let o,f;if(c instanceof L)return null;if(c instanceof E||c instanceof j){if(u)return null;o=c.abiItem.name,f=(a=c.abiItem.inputs)==null?void 0:a.some(p=>!("name"in p&&p.name))}return{...r,args:f?[]:{},eventName:o}}}).filter(Boolean)}function ye(t){const{args:e,inputs:n,matchArgs:s}=t;if(!s)return!0;if(!e)return!1;function u(i,r,a){try{return i.type==="address"?fe(r,a):i.type==="string"||i.type==="bytes"?M($(r))===a:r===a}catch{return!1}}return Array.isArray(e)&&Array.isArray(s)?s.every((i,r)=>{if(i==null)return!0;const a=n[r];return a?(Array.isArray(i)?i:[i]).some(o=>u(a,o,e[r])):!1}):typeof e=="object"&&!Array.isArray(e)&&typeof s=="object"&&!Array.isArray(s)?Object.entries(s).every(([i,r])=>{if(r==null)return!0;const a=n.find(o=>o.name===i);return a?(Array.isArray(r)?r:[r]).some(o=>u(a,o,e[i])):!1}):!1}function he(t){return!!(t&&typeof t=="object"&&"type"in t&&t.type==="event")}function D(t){const{signature:e}=t;let n;return he(e)?n=e:n=H(e),{abiEvent:n,hash:S(n),topics:de({abi:[n],args:t.filters})}}function ge(t){const{logs:e,events:n,strict:s}=t;return me({abi:n.map(u=>u.abiEvent),logs:e,strict:s})}function be(t,e){return e&&(t.__preparedMethod=e.preparedMethod,t.__contract=e.contract),t}function Ue(t){const{contract:e,method:n,params:s,...u}=t,i=()=>(async()=>{var r,a;if(Array.isArray(n))return n;if(V(n))return A(n);if(typeof n=="function")return A(await n(e));if(typeof n=="string"&&n.startsWith("function ")){const c=H(n);if(c.type==="function")return A(c);throw new Error('"method" passed is not of type "function"')}if(e.abi&&((r=e.abi)==null?void 0:r.length)>0){const c=(a=e.abi)==null?void 0:a.find(o=>o.type==="function"&&o.name===n);if(c)return A(c)}throw new Error(`Could not resolve method "${n}".`)})();return be({...u,chain:e.chain,client:e.client,data:async()=>{let r;return Array.isArray(n)?r=n:r=await i(),r[1].length===0?r[0]:r[0]+z(r[1],await Y(s??[])).slice(2)},to:e.address},{contract:e,preparedMethod:i})}function xe(t){let e;return()=>(e||(e=t()),e)}function Ae(t={}){return D({filters:t,signature:"event UserOperationRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason)"})}function ve(t={}){return D({filters:t,signature:"event PostOpRevertReason(bytes32 indexed userOpHash, address indexed sender, uint256 nonce, bytes revertReason)"})}function we(t){const{receipt:e}=t,n={...e,blockNumber:e.blockNumber?BigInt(e.blockNumber):null,contractAddress:e.contractAddress?e.contractAddress:null,cumulativeGasUsed:e.cumulativeGasUsed?BigInt(e.cumulativeGasUsed):null,effectiveGasPrice:e.effectiveGasPrice?BigInt(e.effectiveGasPrice):null,gasUsed:e.gasUsed?BigInt(e.gasUsed):null,logs:e.logs,status:e.status,to:e.to?e.to:null,transactionHash:e.transactionHash,transactionIndex:e.transactionIndex,type:e.type};return e.blobGasPrice&&(n.blobGasPrice=BigInt(e.blobGasPrice)),e.blobGasUsed&&(n.blobGasUsed=BigInt(e.blobGasUsed)),{...t,actualGasCost:BigInt(t.actualGasCost),actualGasUsed:BigInt(t.actualGasUsed),nonce:BigInt(t.nonce),receipt:n,userOpHash:t.userOpHash}}const Pe=()=>{const t=BigInt(Math.floor(Math.random()*4294967296)),e=BigInt(Math.floor(Math.random()*4294967296)),n=BigInt(Math.floor(Math.random()*4294967296)),s=BigInt(Math.floor(Math.random()*4294967296)),u=BigInt(Math.floor(Math.random()*4294967296)),i=BigInt(Math.floor(Math.random()*4294967296));return t<<BigInt(160)|e<<BigInt(128)|n<<BigInt(96)|s<<BigInt(64)|u<<BigInt(32)|i};function k(t){return Object.fromEntries(Object.entries(t).map(([e,n])=>[e,n==null||ee(n)?n:X(n)]))}async function Te(t){return g({...t,operation:"eth_sendUserOperation",params:[k(t.userOp),t.options.entrypointAddress??R]})}async function Be(t,e){const n=await g({...t,operation:"eth_estimateUserOperationGas",params:[k(t.userOp),t.options.entrypointAddress??R,e??{}]});return{callGasLimit:h(n.callGasLimit)+re,paymasterPostOpGasLimit:n.paymasterPostOpGasLimit!==void 0?h(n.paymasterPostOpGasLimit):void 0,paymasterVerificationGasLimit:n.paymasterVerificationGasLimit!==void 0?h(n.paymasterVerificationGasLimit):void 0,preVerificationGas:h(n.preVerificationGas),verificationGas:n.verificationGas!==void 0?h(n.verificationGas):void 0,verificationGasLimit:h(n.verificationGasLimit)}}async function _e(t){const e=await g({...t,operation:"thirdweb_getUserOperationGasPrice",params:[]});return{maxFeePerGas:h(e.maxFeePerGas),maxPriorityFeePerGas:h(e.maxPriorityFeePerGas)}}async function He(t){var n,s;const e=await Ee(t);if(e){if(e.success===!1){const i=(s=(n=ge({events:[Ae(),ve()],logs:e.logs})[0])==null?void 0:n.args)==null?void 0:s.revertReason;if(!i)throw new Error(`UserOp failed at txHash: ${e.receipt.transactionHash}`);const r=oe({data:i});throw new Error(`UserOp failed with reason: '${r.args.join(",")}' at txHash: ${e.receipt.transactionHash}`)}return e.receipt}}async function Ee(t){const e=await g({operation:"eth_getUserOperationReceipt",options:t,params:[t.userOpHash]});if(e)return we(e)}async function Ne(t){const e=await g({operation:"zk_paymasterData",options:t.options,params:[t.transaction]});return{paymaster:e.paymaster,paymasterInput:e.paymasterInput}}async function Me(t){const e=await g({...t,operation:"tw_execute",params:[t.eoaAddress,t.wrappedCalls,t.signature,t.authorization]});if(!e.queueId)throw new Error(`Error executing 7702 transaction: ${I(e)}`);return{transactionId:e.queueId}}async function $e(t){return{transactionHash:(await g({...t,operation:"tw_getTransactionHash",params:[t.transactionId]})).transactionHash}}async function Le(t){return{transactionHash:(await g({operation:"zk_broadcastTransaction",options:t.options,params:[{...t.transaction,signedTransaction:t.signedTransaction}]})).transactionHash}}async function g(t){const{options:e,operation:n,params:s}=t,u=e.bundlerUrl??te(e.chain),r=await ne(e.client)(u,{useAuthToken:!0,body:I({id:1,jsonrpc:"2.0",method:n,params:s}),headers:{"Content-Type":"application/json"},method:"POST"}),a=await r.json();if(!r.ok||a.error){let c=a.error||r.statusText;typeof c=="object"&&(c=I(c));const o=a.code||"UNKNOWN";throw new Error(`${n} error: ${c}
Status: ${r.status}
Code: ${o}`)}return a.result}export{He as a,_e as b,Pe as c,Be as d,Me as e,Ne as f,$e as g,k as h,Le as i,Te as j,xe as o,Ue as p};
