import{w as h,e as p}from"./wait-for-tx-receipt-fxvnR1SM.js";import{ae as w,a9 as m,as as f,e as T}from"./Auth-S95xDGpl.js";import{s as b}from"./send-transaction-BB1bQW86.js";import{r as g}from"./random-Bpp9kTCT.js";import"./to-serializable-transaction-CC4aNdBJ.js";import"./index-CW0o6enZ.js";import"./sleep-mAKpSMLY.js";import"./mail-DvG7XVsR.js";import"./eye-off-CIbWrHRa.js";import"./eye-BDFcKtY7.js";import"./circle-alert-CkwyipiV.js";import"./loader-circle-ByqWHebJ.js";async function H(r){const t=await b(r);return h(t)}async function y(r){const{account:t,transactions:o}=r;if(!t)throw new Error("not connected");if(o.length===0)throw new Error("No transactions to send");const s=o[0];if(!s)throw new Error("No transactions to send");if(t.sendBatchTransaction){const n=await Promise.all(o.map(async a=>{const[u,c,e,l]=await Promise.all([w(a),m(a.to),m(a.accessList),m(a.value)]);return{accessList:e,chainId:a.chain.id,data:u,to:c,value:l}}));return{...await t.sendBatchTransaction(n),chain:s.chain,client:s.client}}throw new Error("Account doesn't implement sendBatchTransaction")}const d=new f(1e3);async function I(r){const{account:t,calls:o}=r,s=[],n=g(65);if(d.set(n,s),t.sendBatchTransaction){const i=await y({account:t,transactions:o});s.push(i.transactionHash),d.set(n,s)}else for(const i of o){const a=await H({account:t,transaction:i});s.push(a.transactionHash),d.set(n,s)}return n}async function S(r){const{chain:t,client:o,id:s}=r,n=d.get(s);if(!n)throw new Error("Failed to get calls status, unknown bundle id");const i=T({chain:t,client:o});let a="success";const u=await Promise.all(n.map(c=>p(i,{hash:c}).then(e=>({blockHash:e.blockHash,blockNumber:e.blockNumber,gasUsed:e.gasUsed,logs:e.logs.map(l=>({address:l.address,data:l.data,topics:l.topics})),status:e.status,transactionHash:e.transactionHash})).catch(()=>(a="pending",null))));return{atomic:!1,chainId:t.id,id:s,receipts:u.filter(c=>c!==null),status:a,statusCode:200,version:"2.0.0"}}export{S as inAppWalletGetCallsStatus,I as inAppWalletSendCalls};
