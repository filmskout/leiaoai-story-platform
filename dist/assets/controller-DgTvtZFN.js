const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/index.es-0yx9EuCz.js","assets/index-lJi5ZKDq.js","assets/index-9Wd0Lgfa.css","assets/Auth-DAqzl9N_.js","assets/mail-rCMurYez.js","assets/eye-off-_xJlegA0.js","assets/eye-CgMDpV-8.js","assets/circle-alert-DSA0x7c1.js","assets/loader-circle-Cf5iuTbA.js"])))=>i.map(i=>d[i]);
import{_ as X}from"./index-lJi5ZKDq.js";import{B as x,k as O,s as q,l as D,n as S,b as g,m as E,o as Q,q as k,c as _,p as Z,r as H,v as ee,u as ne,x as ae,y as te,z as R,t as ie}from"./Auth-DAqzl9N_.js";import"./mail-rCMurYez.js";import"./eye-off-_xJlegA0.js";import"./eye-CgMDpV-8.js";import"./circle-alert-DSA0x7c1.js";import"./loader-circle-Cf5iuTbA.js";const ce=e=>e;class re extends x{constructor({body:a,error:t,url:i}){super("RPC Request failed.",{cause:t,details:t.message,metaMessages:[`URL: ${ce(i)}`,`Request body: ${O(a)}`],name:"RpcRequestError"}),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.code=t.code,this.data=t.data}}const se=-1;class oe extends x{constructor(a,{code:t,docsPath:i,metaMessages:n,name:r,shortMessage:d}){super(d,{cause:a,docsPath:i,metaMessages:n||(a==null?void 0:a.metaMessages),name:r||"RpcError"}),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.name=r||a.name,this.code=a instanceof re?a.code:t??se}}class z extends oe{constructor(a,t){super(a,t),Object.defineProperty(this,"data",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.data=t.data}}class P extends z{constructor(a){super(a,{code:P.code,name:"UserRejectedRequestError",shortMessage:"User rejected the request."})}}Object.defineProperty(P,"code",{enumerable:!0,configurable:!0,writable:!0,value:4001});class I extends z{constructor(a){super(a,{code:I.code,name:"SwitchChainError",shortMessage:"An error occurred when attempting to switch chain."})}}Object.defineProperty(I,"code",{enumerable:!0,configurable:!0,writable:!0,value:4902});const de="08c4b07e3ad25f1a27c14a4e8cecb6f0",J="eip155",U="tw:connected-wallet-params";async function le(e,a,t){if(!he(t))throw new Error("given params are not stringifiable");const i=await e.getItem(U);let n;if(i){try{n=JSON.parse(i)}catch{n={}}n[a]=t}else n={[a]:t};e.setItem(U,q(n))}async function ue(e,a){const t=await e.getItem(U);if(!t)return null;try{const i=JSON.parse(t);return i!=null&&i[a]?i[a]:null}catch{return null}}function he(e){try{return q(e),!0}catch{return!1}}let T=null;const A={lastUsedChainId:"tw.wc.lastUsedChainId",requestedChains:"tw.wc.requestedChains"};async function Pe(e,a,t,i,n){var b,N,j;const r=await V(e,t,n),d=e.walletConnect;let{onDisplayUri:c}=d||{};const s=await D(t);!c&&n&&(c=L=>{const $=s.mobile.native||s.mobile.universal;if(!$){n(L);return}const Y=Q($,L).redirect;n(Y)}),c&&r.events.addListener("display_uri",c);let u=d==null?void 0:d.optionalChains,l=e.chain;t==="global.safe"&&(u=K.map(g),l&&!u.includes(l)&&(l=void 0));const{chains:f,rpcMap:o}=we({chain:l,client:e.client,optionalChains:u});await r.connect({...d!=null&&d.pairingTopic?{pairingTopic:d==null?void 0:d.pairingTopic}:{},optionalNamespaces:{[J]:{chains:f,events:["chainChanged","accountsChanged"],methods:["eth_sendTransaction","eth_signTransaction","eth_sign","personal_sign","eth_signTypedData","eth_signTypedData_v4","wallet_switchEthereumChain","wallet_addEthereumChain"],rpcMap:o}}}),G(f.map(v=>Number(v.split(":")[1])),i);const h=((b=f[0])==null?void 0:b.split(":")[1])||1,m=S(h),p=me(r.session,"eip155:1");if(!p)throw new Error("No accounts found on provider.");const C=e.chain&&e.chain.id===m?e.chain:g(m);if(e){const v={chain:e.chain,optionalChains:(N=e.walletConnect)==null?void 0:N.optionalChains,pairingTopic:(j=e.walletConnect)==null?void 0:j.pairingTopic};i&&le(i,t,v)}return c&&r.events.removeListener("display_uri",c),B(p,C,r,a,i,e.client,s,n)}async function fe(e,a,t){var d,c,s,u,l,f;if(!e.session)throw new Error("No session found on provider.");const i=`eip155:${a.id}`,n=R(a.id);if(W(e.session,i)){e.setDefaultChain(i);return}try{await y({provider:e,payload:{method:"wallet_switchEthereumChain",params:[{chainId:n}]},chain:i,walletInfo:t}),e.setDefaultChain(i);return}catch(o){if(((o==null?void 0:o.code)??((c=(d=o==null?void 0:o.data)==null?void 0:d.originalError)==null?void 0:c.code))===4001)throw new Error("User rejected chain switch")}const r=pe(e.session);if(!r)throw new Error("No routable chain to send wallet_addEthereumChain");try{await y({provider:e,payload:{method:"wallet_addEthereumChain",params:[{chainId:n,chainName:a.name,nativeCurrency:a.nativeCurrency,rpcUrls:[a.rpc],blockExplorerUrls:[((u=(s=a.blockExplorers)==null?void 0:s[0])==null?void 0:u.url)??""]}]},chain:r,walletInfo:t})}catch(o){throw((o==null?void 0:o.code)??((f=(l=o==null?void 0:o.data)==null?void 0:l.originalError)==null?void 0:f.code))===4001?new Error("User rejected add chain"):new Error(`Add chain failed: ${(o==null?void 0:o.message)||String(o)}`)}if(await y({provider:e,payload:{method:"wallet_switchEthereumChain",params:[{chainId:n}]},chain:i,walletInfo:t}),e.setDefaultChain(i),!W(e.session,i))throw new Error("Target chain still not enabled by wallet")}function M(e){var a;return(a=e==null?void 0:e.namespaces)==null?void 0:a.eip155}function W(e,a){var i;const t=M(e);return!!((i=t==null?void 0:t.accounts)!=null&&i.some(n=>n.startsWith(`${a}:`)))}function me(e,a){var n;const t=M(e),i=(n=t==null?void 0:t.accounts)==null?void 0:n.find(r=>r.startsWith(`${a}:`));return i?i.split(":")[2]??null:null}function pe(e){var t,i,n,r;const a=M(e);return((r=(n=(i=(t=a==null?void 0:a.accounts)==null?void 0:t[0])==null?void 0:i.split(":"))==null?void 0:n.slice(0,2))==null?void 0:r.join(":"))??null}async function Ie(e,a,t,i,n){var h,m,w,p,C;const r=i?await ue(i,t):null,d=await D(t),c=await V(r?{chain:r.chain,client:e.client,walletConnect:{optionalChains:r.optionalChains,pairingTopic:r.pairingTopic}}:{client:e.client,walletConnect:{}},t,n);if(!c.session)throw await c.disconnect(),new Error("No wallet connect session found on provider.");const s=(w=(m=(h=c.session)==null?void 0:h.namespaces)==null?void 0:m[J])==null?void 0:w.accounts,u=(p=s==null?void 0:s[0])==null?void 0:p.split(":")[2];if(!u)throw new Error("No accounts found on provider.");const l=((C=e.chain)==null?void 0:C.id)||1,f=S(l),o=e.chain&&e.chain.id===f?e.chain:g(f);return B(u,o,c,a,i,e.client,d,n)}async function V(e,a,t){var u,l,f,o;if(T)return T;const i=await D(a),n=e.walletConnect,{UniversalProvider:r}=await X(async()=>{const{UniversalProvider:h}=await import("./index.es-0yx9EuCz.js");return{UniversalProvider:h}},__vite__mapDeps([0,1,2,3,4,5,6,7,8]));let d=n==null?void 0:n.optionalChains,c=e.chain;a==="global.safe"&&(d=K.map(g),c&&!d.includes(c)&&(c=void 0));const s=await r.init({metadata:{description:((u=n==null?void 0:n.appMetadata)==null?void 0:u.description)||E().description,icons:[((l=n==null?void 0:n.appMetadata)==null?void 0:l.logoUrl)||E().logoUrl],name:((f=n==null?void 0:n.appMetadata)==null?void 0:f.name)||E().name,url:((o=n==null?void 0:n.appMetadata)==null?void 0:o.url)||E().url,redirect:{native:i.mobile.native||void 0,universal:i.mobile.universal||void 0}},projectId:(n==null?void 0:n.projectId)||de});if(s.events.setMaxListeners(Number.POSITIVE_INFINITY),a!=="walletConnect"){async function h(){var w,p,C,b;const m=((b=(C=(p=(w=s.session)==null?void 0:w.peer)==null?void 0:p.metadata)==null?void 0:C.redirect)==null?void 0:b.native)||i.mobile.native||i.mobile.universal;t&&m&&await t(m)}s.on("session_request_sent",h),s.events.addListener("disconnect",()=>{s.off("session_request_sent",h),T=null})}return T=s,s}function F({provider:e,address:a,client:t,chain:i,sessionRequestHandler:n,walletInfo:r}){return{address:_(a),async sendTransaction(c){const s=await y({provider:e,payload:{method:"eth_sendTransaction",params:[{data:c.data,from:_(a),gas:c.gas?R(c.gas):void 0,to:c.to,value:c.value?R(c.value):void 0}]},chain:`eip155:${c.chainId}`,walletInfo:r,sessionRequestHandler:n});return ie({chainId:c.chainId,client:t,contractAddress:c.to??void 0,gasPrice:c.gasPrice,transactionHash:s,walletAddress:_(a),walletType:"walletConnect"}),{transactionHash:s}},async signMessage({message:c}){const s=typeof c=="string"?ae(c):c.raw instanceof Uint8Array?te(c.raw):c.raw;return y({provider:e,payload:{method:"personal_sign",params:[s,this.address]},chain:`eip155:${i.id}`,walletInfo:r,sessionRequestHandler:n})},async signTypedData(c){const s=Z(c),{domain:u,message:l,primaryType:f}=s,o={EIP712Domain:H({domain:u}),...s.types};ee({domain:u,message:l,primaryType:f,types:o});const h=ne({domain:u??{},message:l,primaryType:f,types:o});return await y({provider:e,payload:{method:"eth_signTypedData_v4",params:[this.address,h]},chain:`eip155:${i.id}`,walletInfo:r,sessionRequestHandler:n})}}}async function y(e){var s,u,l,f;const{provider:a,payload:t,chain:i,walletInfo:n,sessionRequestHandler:r}=e,d=a.request(t,i),c=((f=(l=(u=(s=a.session)==null?void 0:s.peer)==null?void 0:u.metadata)==null?void 0:l.redirect)==null?void 0:f.native)||n.mobile.native||n.mobile.universal;return r&&c&&await r(c),d}function B(e,a,t,i,n,r,d,c){const s=F({address:e,chain:a,client:r,provider:t,sessionRequestHandler:c,walletInfo:d});async function u(){t.removeListener("accountsChanged",f),t.removeListener("chainChanged",o),t.removeListener("disconnect",l),await t.disconnect(),T=null}function l(){G([],n),n==null||n.removeItem(A.lastUsedChainId),u(),i.emit("disconnect",void 0)}function f(h){if(h[0]){const m=F({address:_(h[0]),chain:a,client:r,provider:t,sessionRequestHandler:c,walletInfo:d});i.emit("accountChanged",m),i.emit("accountsChanged",h)}else l()}function o(h){const m=g(S(h));i.emit("chainChanged",m),n==null||n.setItem(A.lastUsedChainId,String(h))}return t.on("accountsChanged",f),t.on("chainChanged",o),t.on("disconnect",l),t.on("session_delete",l),[s,a,u,h=>Ce(t,h,d)]}async function Ce(e,a,t){try{await fe(e,a,t)}catch(i){const n=typeof i=="string"?i:i==null?void 0:i.message;throw/user rejected request/i.test(n)?new P(i):new I(i)}}function G(e,a){a==null||a.setItem(A.requestedChains,q(e))}function we(e){const a={},t=[];e.chain&&(a[e.chain.id]=k({chain:e.chain,client:e.client}),t.push(e.chain.id));const i=((e==null?void 0:e.optionalChains)||[]).slice(0,10);for(const n of i)a[n.id]=k({chain:n,client:e.client}),t.push(n.id);return t.includes(1)||(a[1]=g(1).rpc,t.push(1)),{chains:t.map(n=>`eip155:${n}`),rpcMap:a}}const K=[1,11155111,42161,43114,8453,1313161554,84532,56,42220,100,10,137,1101,324,534352];export{Ie as autoConnectWC,Pe as connectWC};
