import type { VercelRequest, VercelResponse } from '@vercel/node';
import { createClient } from '@supabase/supabase-js';
import mammoth from 'mammoth';

/**
 * ÊñáÊú¨ÊèêÂèñAPI
 * ÊîØÊåÅÂ§öÁßçÊ®°ÂºèÔºö
 * 1. URLÊ®°ÂºèÔºöÁõ¥Êé•‰ΩøÁî®imageUrlÔºàÁî®‰∫éBMCÂõæÁâáÔºå‰ΩøÁî®OpenAI VisionÔºâ
 * 2. DOCXÊñá‰ª∂Ôºö‰ªéSupabase‰∏ãËΩΩÂπ∂ÊèêÂèñÊñáÊú¨Ôºà‰ΩøÁî®mammothÔºâ
 * 3. PDFÊñá‰ª∂ÔºöËøîÂõûÂèãÂ•ΩÈîôËØØÊèêÁ§∫ÔºåÂª∫ËÆÆËΩ¨Êç¢‰∏∫DOCXÊàñÊñáÊú¨
 * 4. ÂõæÁâáÊñá‰ª∂Ôºö‰ªéSupabase‰∏ãËΩΩÂπ∂OCRÔºà‰ΩøÁî®OpenAI VisionÔºâ
 */
export default async function handler(req: VercelRequest, res: VercelResponse) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method Not Allowed' });
  }

  try {
    const { image, imageUrl, filePath, fileType } = req.body;
    
    let imageData = image || imageUrl;
    let extractedText: string | null = null;
    
    // Â¶ÇÊûúÊèê‰æõÁöÑÊòØSupabaseÊñá‰ª∂Ë∑ØÂæÑÔºå‰ªéStorage‰∏ãËΩΩ
    if (filePath && !imageData) {
      console.log('üîµ Text Extract: Using server-side download mode');
      console.log('   File path:', filePath);
      console.log('   File type:', fileType);
      
      const supabaseUrl = process.env.VITE_SUPABASE_URL || process.env.SUPABASE_URL;
      const secretKey = process.env.SUPABASE_SECRET_KEY || process.env.SUPABASE_SERVICE_ROLE_KEY;
      
      if (!supabaseUrl) {
        console.error('‚ùå Missing SUPABASE_URL');
        return res.status(500).json({ 
          error: 'Server misconfigured: missing SUPABASE_URL' 
        });
      }
      
      if (!secretKey) {
        console.error('‚ùå Missing SUPABASE_SECRET_KEY');
        return res.status(500).json({ 
          error: 'Server misconfigured: missing SUPABASE_SECRET_KEY' 
        });
      }
      
      console.log('üîµ Using Supabase Secret Key authentication');
      
      const supabase = createClient(supabaseUrl, secretKey, {
        auth: {
          persistSession: false,
          autoRefreshToken: false
        },
        global: {
          headers: {
            'X-Client-Info': 'leoai-text-extract-api'
          }
        }
      });
      
      console.log('üîµ Downloading file from Supabase Storage...');
      
      const { data: fileData, error: downloadError } = await supabase.storage
        .from('bp-documents')
        .download(filePath);
      
      if (downloadError) {
        console.error('‚ùå Failed to download file', {
          error: downloadError.message,
          filePath
        });
        return res.status(500).json({ 
          error: 'Failed to download file from storage',
          details: downloadError.message 
        });
      }
      
      console.log('‚úÖ File downloaded successfully');
      console.log('   File size:', fileData.size, 'bytes');
      console.log('   File type:', fileData.type);
      
      // Âà§Êñ≠Êñá‰ª∂Á±ªÂûãÔºöPDF‰ΩøÁî®pdf-parseÔºåÂõæÁâá‰ΩøÁî®OpenAI Vision
      const mimeType = fileData.type || fileType || 'application/pdf';
      
      if (mimeType === 'application/pdf' || filePath.toLowerCase().endsWith('.pdf')) {
        // PDFÊñá‰ª∂ÔºöÂ∞ùËØï‰ΩøÁî®pdf-to-docxËΩ¨Êç¢ÊúçÂä°
        console.log('üîµ PDF detected: Attempting auto-conversion to DOCX...');
        
        try {
          // Ë∞ÉÁî®PDFËΩ¨DOCXÊúçÂä°
          const conversionResponse = await fetch(`${req.headers.origin || 'https://leiaoai-story-platform.vercel.app'}/api/pdf-to-docx`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ filePath })
          });

          if (conversionResponse.ok) {
            const conversionData = await conversionResponse.json();
            console.log('‚úÖ PDF converted to DOCX, downloading...');

            // ‰∏ãËΩΩËΩ¨Êç¢ÂêéÁöÑDOCX
            const docxResponse = await fetch(conversionData.docxUrl);
            const docxBlob = await docxResponse.arrayBuffer();
            const docxBuffer = Buffer.from(docxBlob);

            // ‰ΩøÁî®mammothÊèêÂèñÊñáÊú¨
            console.log('üîµ Extracting text from converted DOCX...');
            const result = await mammoth.extractRawText({ buffer: docxBuffer });
            extractedText = result.value.trim();

            console.log('‚úÖ Text extracted from converted DOCX');
            console.log('   Text length:', extractedText.length);

            if (!extractedText || extractedText.length === 0) {
              throw new Error('Converted DOCX contains no text');
            }

            return res.status(200).json({
              extractedText,
              text: extractedText,
              source: 'pdf-to-docx-auto-conversion',
              success: true,
              message: 'PDFÂ∑≤Ëá™Âä®ËΩ¨Êç¢‰∏∫DOCXÂπ∂ÊèêÂèñÊñáÊú¨'
            });
          } else {
            // ËΩ¨Êç¢ÊúçÂä°‰∏çÂèØÁî®ÔºåËøîÂõûÂèãÂ•ΩÊèêÁ§∫
            const errorData = await conversionResponse.json().catch(() => ({}));
            
            if (errorData.configured === false) {
              console.log('‚ö†Ô∏è PDF conversion service not configured');
              return res.status(400).json({
                error: 'PDFÊñá‰ª∂ÈúÄË¶ÅËΩ¨Êç¢',
                details: 'Ëá™Âä®PDFËΩ¨Êç¢ÊúçÂä°Êú™ÈÖçÁΩÆ„ÄÇ\n\nËØ∑ÈÄâÊã©‰ª•‰∏ã‰ªª‰∏ÄÊñπÂºèÔºö\n1. Â∞ÜPDFËΩ¨Êç¢‰∏∫WordÊñáÊ°£Ôºà.docxÔºâÂêé‰∏ä‰º†\n2. Â§çÂà∂PDF‰∏≠ÁöÑÊñáÊú¨ÂÜÖÂÆπÔºåÁõ¥Êé•Á≤òË¥¥\n\nÂú®Á∫øËΩ¨Êç¢Â∑•ÂÖ∑: https://www.ilovepdf.com/pdf_to_word',
                suggestion: 'Âª∫ËÆÆÔºö‰ΩøÁî® .docx Êñá‰ª∂ÊàñÂú®Á∫øËΩ¨Êç¢Â∑•ÂÖ∑',
                canAutoConvert: false
              });
            }

            throw new Error(`Conversion failed: ${errorData.error || 'Unknown error'}`);
          }
        } catch (conversionError: any) {
          console.error('‚ùå PDF conversion failed:', conversionError.message);
          
          // ËøîÂõûÂèãÂ•ΩÁöÑÈîôËØØÊèêÁ§∫
          return res.status(400).json({
            error: 'PDFËá™Âä®ËΩ¨Êç¢Â§±Ë¥•',
            details: `Êó†Ê≥ïËá™Âä®ËΩ¨Êç¢PDFÊñá‰ª∂„ÄÇ\n\nËØ∑ÊâãÂä®Êìç‰ΩúÔºö\n1. Â∞ÜPDFËΩ¨Êç¢‰∏∫WordÊñáÊ°£Ôºà.docxÔºâÂêé‰∏ä‰º†\n2. Êàñ‰ΩøÁî®Âú®Á∫øÂ∑•ÂÖ∑: https://www.ilovepdf.com/pdf_to_word\n3. ÊàñÂ§çÂà∂PDF‰∏≠ÁöÑÊñáÊú¨ÂÜÖÂÆπÁõ¥Êé•Á≤òË¥¥\n\nÈîôËØØËØ¶ÊÉÖ: ${conversionError.message}`,
            suggestion: 'Âª∫ËÆÆÔºöÊâãÂä®ËΩ¨Êç¢‰∏∫ .docx Êñá‰ª∂',
            canAutoConvert: false
          });
        }
      } else if (mimeType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' || filePath.toLowerCase().endsWith('.docx')) {
        // DOCXÊñá‰ª∂Ôºö‰ΩøÁî®mammothÊèêÂèñÊñáÊú¨
        console.log('üîµ DOCX detected: Using mammoth for text extraction');
        
        try {
          const arrayBuffer = await fileData.arrayBuffer();
          const buffer = Buffer.from(arrayBuffer);
          
          console.log('üîµ Extracting text from DOCX...');
          const result = await mammoth.extractRawText({ buffer });
          
          extractedText = result.value.trim();
          
          console.log('‚úÖ DOCX text extracted successfully');
          console.log('   Text length:', extractedText.length);
          console.log('   Text preview:', extractedText.substring(0, 200));
          
          if (!extractedText || extractedText.length === 0) {
            return res.status(400).json({
              error: 'DOCXÊñá‰ª∂‰∏∫Á©∫',
              details: 'The DOCX file contains no readable text.'
            });
          }
          
          // Áõ¥Êé•ËøîÂõûÊèêÂèñÁöÑÊñáÊú¨
          return res.status(200).json({
            extractedText,
            text: extractedText,
            source: 'mammoth',
            success: true
          });
          
        } catch (docxError: any) {
          console.error('‚ùå DOCX extraction failed:', docxError);
          return res.status(500).json({
            error: 'DOCXÊñáÊú¨ÊèêÂèñÂ§±Ë¥•',
            details: docxError.message || 'Failed to extract text from DOCX'
          });
        }
      } else {
        // ÂõæÁâáÊñá‰ª∂ÔºöËΩ¨Êç¢‰∏∫Base64‰æõOpenAI Vision‰ΩøÁî®
        console.log('üîµ Image detected: Converting to Base64 for OpenAI Vision');
        const arrayBuffer = await fileData.arrayBuffer();
        const base64 = Buffer.from(arrayBuffer).toString('base64');
        
        console.log('‚úÖ Converted to Base64');
        console.log('   Base64 length:', base64.length);
        
        imageData = `data:${mimeType};base64,${base64}`;
      }
    }
    
    // È™åËØÅimageData
    if (!imageData) {
      return res.status(400).json({ 
        error: 'Either imageUrl or filePath is required' 
      });
    }

    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      return res.status(500).json({ error: 'Server misconfigured: missing OPENAI_API_KEY' });
    }

    console.log('üîç Starting OCR extraction...', {
      urlLength: imageData.length,
      urlPreview: imageData.substring(0, 100),
      isDataUrl: imageData.startsWith('data:'),
      isHttpUrl: imageData.startsWith('http'),
      sizeInMB: (imageData.length / (1024 * 1024)).toFixed(2)
    });

    // OpenAI Vision APIÈôêÂà∂ÔºöBase64‰∏çËÉΩË∂ÖËøá20MB
    const maxSize = 20 * 1024 * 1024; // 20MB
    if (imageData.length > maxSize) {
      console.error('‚ùå OCR: File too large for OpenAI Vision API', {
        size: imageData.length,
        maxSize,
        sizeInMB: (imageData.length / (1024 * 1024)).toFixed(2)
      });
      return res.status(400).json({ 
        error: `Êñá‰ª∂Â§™Â§ß„ÄÇOpenAI Vision APIÈôêÂà∂‰∏∫20MBÔºåÂΩìÂâçÊñá‰ª∂‰∏∫ ${(imageData.length / (1024 * 1024)).toFixed(2)}MB`,
        details: 'Please upload a smaller file or reduce the PDF quality'
      });
    }

    console.log('üîµ OCR: Calling OpenAI Vision API...');

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'gpt-4o',
        messages: [
          {
            role: 'user',
            content: [
              {
                type: 'text',
                text: imageData.startsWith('data:application/pdf')
                  ? 'Extract all text content from this PDF document. Return ONLY the extracted text, preserving the structure and paragraphs. Do not add any commentary, explanations, or formatting. Just the raw text from the PDF.'
                  : 'Extract all text from this image. Please return ONLY the extracted text, without any additional commentary or formatting. Extract all readable text you can see.'
              },
              {
                type: 'image_url',
                image_url: {
                  url: imageData,
                  detail: 'high' // ‰ΩøÁî®È´òÊ∏ÖÊ®°Âºè‰ª•Ëé∑ÂæóÊõ¥Â•ΩÁöÑÊñáÊú¨ËØÜÂà´
                }
              }
            ]
          }
        ],
        max_tokens: 16000 // Â§ßÂπÖÂ¢ûÂä†tokenÈôêÂà∂‰ª•ÊîØÊåÅÊõ¥ÈïøÁöÑPDFÊñáÊ°£
      })
    });

    console.log('üîµ OpenAI API response status:', response.status);

    if (!response.ok) {
      const errorText = await response.text();
      let errorDetail = errorText;
      
      // Â∞ùËØïËß£ÊûêJSONÈîôËØØ
      try {
        const errorJson = JSON.parse(errorText);
        errorDetail = errorJson.error?.message || errorText;
        console.error('‚ùå OpenAI API error:', {
          status: response.status,
          error: errorJson,
          fullError: errorText.slice(0, 1000)
        });
      } catch (e) {
        console.error('‚ùå OpenAI API error (raw):', {
          status: response.status,
          error: errorText.slice(0, 1000)
        });
      }
      
      // Êèê‰æõÊõ¥ÂÖ∑‰ΩìÁöÑÈîôËØØÊ∂àÊÅØ
      let errorMessage = 'OCR extraction failed';
      if (response.status === 401) {
        errorMessage = 'OpenAI API keyÊó†ÊïàÊàñÁº∫Â§±';
      } else if (response.status === 400) {
        errorMessage = `OpenAI APIËØ∑Ê±ÇÊó†Êïà: ${errorDetail}`;
      } else if (response.status === 429) {
        errorMessage = 'OpenAI APIËØ∑Ê±ÇÈ¢ëÁéáË∂ÖÈôê';
      } else if (response.status === 413) {
        errorMessage = 'Êñá‰ª∂Â§™Â§ßÔºåOpenAIÊó†Ê≥ïÂ§ÑÁêÜ';
      }
      
      return res.status(response.status).json({ 
        error: errorMessage,
        details: errorDetail.slice(0, 500),
        status: response.status
      });
    }

    const data = await response.json();
    extractedText = data?.choices?.[0]?.message?.content; // ‰ΩøÁî®Â∑≤Â£∞ÊòéÁöÑÂèòÈáè

    if (!extractedText) {
      console.error('‚ùå Invalid response from OpenAI');
      return res.status(502).json({ error: 'Invalid response from AI service' });
    }

    console.log('‚úÖ OCR extraction successful, text length:', extractedText.length);

    return res.status(200).json({
      extractedText: extractedText, // ÂâçÁ´ØÊúüÊúõÁöÑÂ≠óÊÆµÂêç
      text: extractedText, // ‰øùÁïôÂÖºÂÆπÊÄß
      success: true
    });

  } catch (error: any) {
    console.error('üí• OCR extraction error:', error?.message || error);
    return res.status(500).json({
      error: error?.message || 'Internal Server Error'
    });
  }
}

